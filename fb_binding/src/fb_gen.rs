// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum entityOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct entity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for entity<'a> {
  type Inner = entity<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> entity<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_T_I8: flatbuffers::VOffsetT = 6;
  pub const VT_T_U8: flatbuffers::VOffsetT = 8;
  pub const VT_T_BOOL: flatbuffers::VOffsetT = 10;
  pub const VT_T_I16: flatbuffers::VOffsetT = 12;
  pub const VT_T_U16: flatbuffers::VOffsetT = 14;
  pub const VT_T_I32: flatbuffers::VOffsetT = 16;
  pub const VT_T_U32: flatbuffers::VOffsetT = 18;
  pub const VT_T_F32: flatbuffers::VOffsetT = 20;
  pub const VT_T_U64: flatbuffers::VOffsetT = 22;
  pub const VT_T_I64: flatbuffers::VOffsetT = 24;
  pub const VT_T_F64: flatbuffers::VOffsetT = 26;
  pub const VT_T_STRING: flatbuffers::VOffsetT = 28;
  pub const VT_T_VEC_U8: flatbuffers::VOffsetT = 30;
  pub const VT_T_VEC_STRING: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    entity { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args entityArgs<'args>
  ) -> flatbuffers::WIPOffset<entity<'bldr>> {
    let mut builder = entityBuilder::new(_fbb);
    builder.add_t_f64(args.t_f64);
    builder.add_t_i64(args.t_i64);
    builder.add_t_u64(args.t_u64);
    builder.add_id(args.id);
    if let Some(x) = args.t_vec_string { builder.add_t_vec_string(x); }
    if let Some(x) = args.t_vec_u8 { builder.add_t_vec_u8(x); }
    if let Some(x) = args.t_string { builder.add_t_string(x); }
    builder.add_t_f32(args.t_f32);
    builder.add_t_u32(args.t_u32);
    builder.add_t_i32(args.t_i32);
    builder.add_t_u16(args.t_u16);
    builder.add_t_i16(args.t_i16);
    builder.add_t_bool(args.t_bool);
    builder.add_t_u8(args.t_u8);
    builder.add_t_i8(args.t_i8);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(entity::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_i8(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(entity::VT_T_I8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_u8(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(entity::VT_T_U8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_bool(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(entity::VT_T_BOOL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn t_i16(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(entity::VT_T_I16, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_u16(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(entity::VT_T_U16, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_i32(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(entity::VT_T_I32, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_u32(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(entity::VT_T_U32, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_f32(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(entity::VT_T_F32, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn t_u64(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(entity::VT_T_U64, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_i64(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(entity::VT_T_I64, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t_f64(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(entity::VT_T_F64, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn t_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(entity::VT_T_STRING, None)}
  }
  #[inline]
  pub fn t_vec_u8(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(entity::VT_T_VEC_U8, None)}
  }
  #[inline]
  pub fn t_vec_string(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(entity::VT_T_VEC_STRING, None)}
  }
}

impl flatbuffers::Verifiable for entity<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<i8>("t_i8", Self::VT_T_I8, false)?
     .visit_field::<u8>("t_u8", Self::VT_T_U8, false)?
     .visit_field::<bool>("t_bool", Self::VT_T_BOOL, false)?
     .visit_field::<i16>("t_i16", Self::VT_T_I16, false)?
     .visit_field::<u16>("t_u16", Self::VT_T_U16, false)?
     .visit_field::<i32>("t_i32", Self::VT_T_I32, false)?
     .visit_field::<u32>("t_u32", Self::VT_T_U32, false)?
     .visit_field::<f32>("t_f32", Self::VT_T_F32, false)?
     .visit_field::<u64>("t_u64", Self::VT_T_U64, false)?
     .visit_field::<i64>("t_i64", Self::VT_T_I64, false)?
     .visit_field::<f64>("t_f64", Self::VT_T_F64, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("t_string", Self::VT_T_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("t_vec_u8", Self::VT_T_VEC_U8, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("t_vec_string", Self::VT_T_VEC_STRING, false)?
     .finish();
    Ok(())
  }
}
pub struct entityArgs<'a> {
    pub id: u64,
    pub t_i8: i8,
    pub t_u8: u8,
    pub t_bool: bool,
    pub t_i16: i16,
    pub t_u16: u16,
    pub t_i32: i32,
    pub t_u32: u32,
    pub t_f32: f32,
    pub t_u64: u64,
    pub t_i64: i64,
    pub t_f64: f64,
    pub t_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub t_vec_u8: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub t_vec_string: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for entityArgs<'a> {
  #[inline]
  fn default() -> Self {
    entityArgs {
      id: 0,
      t_i8: 0,
      t_u8: 0,
      t_bool: false,
      t_i16: 0,
      t_u16: 0,
      t_i32: 0,
      t_u32: 0,
      t_f32: 0.0,
      t_u64: 0,
      t_i64: 0,
      t_f64: 0.0,
      t_string: None,
      t_vec_u8: None,
      t_vec_string: None,
    }
  }
}

pub struct entityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> entityBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(entity::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_t_i8(&mut self, t_i8: i8) {
    self.fbb_.push_slot::<i8>(entity::VT_T_I8, t_i8, 0);
  }
  #[inline]
  pub fn add_t_u8(&mut self, t_u8: u8) {
    self.fbb_.push_slot::<u8>(entity::VT_T_U8, t_u8, 0);
  }
  #[inline]
  pub fn add_t_bool(&mut self, t_bool: bool) {
    self.fbb_.push_slot::<bool>(entity::VT_T_BOOL, t_bool, false);
  }
  #[inline]
  pub fn add_t_i16(&mut self, t_i16: i16) {
    self.fbb_.push_slot::<i16>(entity::VT_T_I16, t_i16, 0);
  }
  #[inline]
  pub fn add_t_u16(&mut self, t_u16: u16) {
    self.fbb_.push_slot::<u16>(entity::VT_T_U16, t_u16, 0);
  }
  #[inline]
  pub fn add_t_i32(&mut self, t_i32: i32) {
    self.fbb_.push_slot::<i32>(entity::VT_T_I32, t_i32, 0);
  }
  #[inline]
  pub fn add_t_u32(&mut self, t_u32: u32) {
    self.fbb_.push_slot::<u32>(entity::VT_T_U32, t_u32, 0);
  }
  #[inline]
  pub fn add_t_f32(&mut self, t_f32: f32) {
    self.fbb_.push_slot::<f32>(entity::VT_T_F32, t_f32, 0.0);
  }
  #[inline]
  pub fn add_t_u64(&mut self, t_u64: u64) {
    self.fbb_.push_slot::<u64>(entity::VT_T_U64, t_u64, 0);
  }
  #[inline]
  pub fn add_t_i64(&mut self, t_i64: i64) {
    self.fbb_.push_slot::<i64>(entity::VT_T_I64, t_i64, 0);
  }
  #[inline]
  pub fn add_t_f64(&mut self, t_f64: f64) {
    self.fbb_.push_slot::<f64>(entity::VT_T_F64, t_f64, 0.0);
  }
  #[inline]
  pub fn add_t_string(&mut self, t_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(entity::VT_T_STRING, t_string);
  }
  #[inline]
  pub fn add_t_vec_u8(&mut self, t_vec_u8: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(entity::VT_T_VEC_U8, t_vec_u8);
  }
  #[inline]
  pub fn add_t_vec_string(&mut self, t_vec_string: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(entity::VT_T_VEC_STRING, t_vec_string);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> entityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    entityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<entity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for entity<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("entity");
      ds.field("id", &self.id());
      ds.field("t_i8", &self.t_i8());
      ds.field("t_u8", &self.t_u8());
      ds.field("t_bool", &self.t_bool());
      ds.field("t_i16", &self.t_i16());
      ds.field("t_u16", &self.t_u16());
      ds.field("t_i32", &self.t_i32());
      ds.field("t_u32", &self.t_u32());
      ds.field("t_f32", &self.t_f32());
      ds.field("t_u64", &self.t_u64());
      ds.field("t_i64", &self.t_i64());
      ds.field("t_f64", &self.t_f64());
      ds.field("t_string", &self.t_string());
      ds.field("t_vec_u8", &self.t_vec_u8());
      ds.field("t_vec_string", &self.t_vec_string());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `entity`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_unchecked`.
pub fn root_as_entity(buf: &[u8]) -> Result<entity, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<entity>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `entity` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_entity_unchecked`.
pub fn size_prefixed_root_as_entity(buf: &[u8]) -> Result<entity, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<entity>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `entity` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_unchecked`.
pub fn root_as_entity_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<entity<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<entity<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `entity` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_unchecked`.
pub fn size_prefixed_root_as_entity_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<entity<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<entity<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a entity and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `entity`.
pub unsafe fn root_as_entity_unchecked(buf: &[u8]) -> entity {
  flatbuffers::root_unchecked::<entity>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed entity and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `entity`.
pub unsafe fn size_prefixed_root_as_entity_unchecked(buf: &[u8]) -> entity {
  flatbuffers::size_prefixed_root_unchecked::<entity>(buf)
}
#[inline]
pub fn finish_entity_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<entity<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_entity_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<entity<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
